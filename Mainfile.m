Clear_data_Keep_debug;

RANDOM_SEED = 21; %set by user to control the randomness

Set_Parameters;

%% Initialization

% Mobility model -----------
Initialization_Mobility_Model;
% -------------------------------------
% Network parameters
Initialization_Network_Parameters;
% -------------------------------------
% Simulation parameters
Initialization_Simulation_Parameters;



%% Setup VUE locations.
% VUEs are tracked by assuming they move along the center of the lane
[...
    TX_location_center, ...
    RX_location_center, ...
    VUE_NS_direction_TX, ...
    VUE_NS_direction_RX, ...
    VUE_EW_direction_TX, ...
    VUE_EW_direction_RX ...
    ] = Initialize_VUE_Locations( ...
    offset_fixed, ...
    RANDOM_SEED ...
    );

% Actual position of VUEs in lanes are obtained by shifting the centers to
% respective direction/lane. Note that _shifted matrix contains the actual
% collision-free locations.
[TX_location_shifted, ...
    RX_location_shifted ...
    ] = Set_VUE_Lanes(...
    TX_location_center, ...
    RX_location_center, ...
    VUE_NS_direction_TX, ...
    VUE_NS_direction_RX, ...
    VUE_EW_direction_TX, ...
    VUE_EW_direction_RX ...
    );

% Plot layout
if (show_figures)
    figure_layout = figure();
    Plot_Manhattan(figure_layout, TX_location_shifted, RX_location_shifted, ...
        VUE_NS_direction_TX, ...
        VUE_NS_direction_RX, ...
        VUE_EW_direction_TX, ...
        VUE_EW_direction_RX, ...
        show_directions ...
        );
end

%% move vehicles
% figure()
for t = 1: simulation_time
    
    
    %% Updating location
    % move centers
    [...
        TX_location_center, ...
        RX_location_center, ...
        VUE_NS_direction_TX, ...
        VUE_EW_direction_TX, ...
        VUE_NS_direction_RX, ...
        VUE_EW_direction_RX ...
        ] = Update_VUE_Locations(...
        TX_location_center, ...
        RX_location_center, ...
        VUE_NS_direction_TX, ...
        VUE_EW_direction_TX, ...
        VUE_NS_direction_RX, ...
        VUE_EW_direction_RX, ...
        random_seeds_location(t) ...
        );
    % move to correct lanes
    [TX_location_shifted, ...
        RX_location_shifted ...
        ] = Set_VUE_Lanes(...
        TX_location_center, ...
        RX_location_center, ...
        VUE_NS_direction_TX, ...
        VUE_NS_direction_RX, ...
        VUE_EW_direction_TX, ...
        VUE_EW_direction_RX ...
        );
    % Plot layout
    if (show_figures)
        Plot_Manhattan(figure_layout, TX_location_shifted, RX_location_shifted, ...
            VUE_NS_direction_TX, ...
            VUE_NS_direction_RX, ...
            VUE_EW_direction_TX, ...
            VUE_EW_direction_RX, ...
            show_directions ...
            );
    end
    
    %{}
    %% Generate channels
    % rows - TX index
    % columns - RX index
    % block - RB index
    channel ...
        = Generate_Channels( ...
        TX_location_shifted, ...
        RX_location_shifted, ....
        VUE_NS_direction_TX, ....
        VUE_NS_direction_RX, ...
        VUE_EW_direction_TX, ...
        VUE_EW_direction_RX, ...
        random_seeds_channel(t) ...
        );
    %}
    %% RB allocation for VUE clusters
    current_random_state = rng;
    rng(RANDOM_SEED);
    
    if mod(t-1,t_clustering) == 0
        if (perform_cluster_based_RBs) %cluster based RB allocation
            resource_allocation_table ...
                = Clustering_VUEs_n_RBs( ...
                Queues(:, t), ...
                TX_location_shifted, ...
                RX_location_shifted ...
                );
        elseif (perform_random_RBs) % random RB allocation
            resource_allocation_table = ...
                zeros( total_VUE_pairs, total_resource_blocks);
            VUE_RBs = randi( total_resource_blocks, [total_VUE_pairs, 1]);
            for pair = 1:total_VUE_pairs
                resource_allocation_table(...
                    pair,randperm(total_resource_blocks, VUE_RBs(pair))) = 1;
            end
        else % all RBs for all VUEs
            resource_allocation_table = ...
                ones( total_VUE_pairs, total_resource_blocks);
        end
    end
    
    rng(current_random_state);
    
    %% Generate arrivals
    % Arrivals(:,t) bits arrived at each VUE pair.
    arrived_packets = poissrnd( average_packet_arrivals*coherence_time, ...
        [total_VUE_pairs, 1]);
    for pair = 1:total_VUE_pairs
        Arrivals(pair,t) = sum( ...
            exprnd( average_packet_size, [ 1, arrived_packets(pair)]), 2)...
            /(bandwidth*coherence_time);
    end
    
    
    %% Calculate power
    [ ...
    transmit_power_this, ...
    queue_exceed_indicator ...
    ] = Power_Allocation(...
    t, ...
    Queues, ...
    Arrivals, ...
    threshold_Q, ...
    include_federated_learning, ...
    virtual_queue_reliability, ...
    virtual_queue_moment_1, ...
    channel, ...
    resource_allocation_table, ...
    interferenceNnoice_estimation ...
    );
    Transmit_power(:,t) = sum( transmit_power_this, 3);
    %transmit_power_this = 1/total_resource_blocks; % needs to be the output of optimization
    
    %% Calculate rate
    power2channel = bsxfun(@times, transmit_power_this, channel);
    %     power2channel = bsxfun(@times, Transmit_power(:,t,:), channel);
    signalNinterference = sum( power2channel, 1) + noise;
    signal = sum( repmat(eye(total_VUE_pairs), ...
        [1,1,total_resource_blocks]).*power2channel, 1);
    Capacity(:,t,:) = ...
        reshape( log2( signalNinterference./(signalNinterference - signal) ),...
        [total_VUE_pairs, 1, total_resource_blocks]);
    
    Rate(:,t) = min( sum( Capacity(:,t,:), 3), Queues(:,t) + Arrivals(:,t) );
    
    %% interference estiamtion
    interferenceNnoice_estimation = weight_old_est*interferenceNnoice_estimation + ...
        (1-weight_old_est)*reshape( signalNinterference - signal, ...
        [total_VUE_pairs, total_resource_blocks]);
    
    %% Queue update
    Queues(:,t) = Queues(:,t) + Arrivals(:,t) - Rate(:,t);
    if(t<simulation_time)
        Queues(:,t+1) = Queues(:,t);
    end
    
    %% Virtual queue updates
    %{}
    if(t<simulation_time)
        % relaibility related---------------------
        % Markov inequality
        %virtual_queue_reliability(:,t+1) = max( ...
        %    virtual_queue_reliability(:,t) + Queues(:,t+1) ...
        %    - violation_probability*threshold_Q, 0);
        % counting measure
        if (include_reliability_constraint)
            virtual_queue_reliability(:,t+1) = max( ...
                virtual_queue_reliability(:,t) + ...
                (Queues(:,t)>threshold_Q) - violation_probability, 0);
        end
        if (include_federated_learning)
            % first moment of max queue related-------
            virtual_queue_moment_1(:,t+1) = virtual_queue_moment_1(:,t);
            virtual_queue_moment_1(queue_exceed_indicator,t+1) = max( ...
                virtual_queue_moment_1(queue_exceed_indicator,t) ...
                + Queues(queue_exceed_indicator,t+1) ...
                - threshold_maxQ_moment_1, 0);
            % second moment of max queue related-----
            %------------removed for POT
            %         virtual_queue_moment_2(:,t+1) = virtual_queue_moment_2(:,t);
            %         virtual_queue_moment_2(queue_exceed_indicator,t+1) = max( ...
            %             virtual_queue_moment_2(queue_exceed_indicator,t) ...
            %             + (Queues(queue_exceed_indicator,t+1)).^2 ...
            %             - threshold_maxQ_moment_2, 0);
        end
    end
    %{}
    
    %% ********************************************************************
    %% Federated learning related
    %{}
    if (include_federated_learning)
        % PoT queue sampling
        if mod(t, window_sampling)==0
            % increment sampling time index
            t_sampling = t_sampling + 1;
            maximum_queues(:, t_sampling) = ...
                max( Queues(:, (t+1-window_sampling):t), [], 2);
            %         %% Local learning
            %         for pair = 1:total_VUE_pairs
            %         end
        end
        % Federated_Learning;
%         Federated_Learning_POT;
        Federated_Learning_POT_cen;
    end
    %}
    
    if mod(t,window_federated*window_sampling) == 0
        Save_data;
        %         disp(['Data saving completed at time = ' num2str(t)]);
    end
    
    % ********************************************************************
    %%
    %     hold on
    %     %     plot( t, mean( sum( Capacity(:,t,:), 3)), '.b');
    %     plot( t, mean(Queues(:,t)), '.b');
    % plot( maximum_queues(4, 1:t_sampling), '.b');
    %         stem(Queues(:,t));
    %             pause(0.00001);
    %}
end
% disp('Simulation completed.');
