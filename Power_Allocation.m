function [ ...
    transmit_power_this, ...
    queue_exceed_indicator ...
    ] = Power_Allocation(...
    t, ...
    Queues, ...
    Arrivals, ...
    threshold_Q, ...
    include_federated_learning, ...
    virtual_queue_reliability, ...
    virtual_queue_moment_1, ...
    channel, ...
    resource_allocation_table, ...
    interferenceNnoice_estimation ...
    )
% Power_Allocation
% Water filling algorithm + Lypunov queue constraints

global total_resource_blocks max_transmit_power
global bandwidth tradeoff_lyapunov
global total_VUE_pairs

transmit_power_this = zeros( total_VUE_pairs, 1, total_resource_blocks);
%---------removed for POT
% queue_exceed_indicator = ( 1 + evtParam_local(:,3).*...
%     (Queues(:,t) + Arrivals(:,t) - evtParam_local(:,1))./...
%     evtParam_local(:,2) ) > 0;
queue_violation_indicator = ( Queues(:,t) + Arrivals(:,t) > threshold_Q );
queue_exceed_indicator = (queue_violation_indicator ...
    * include_federated_learning == 1);

% queue_exceed_counter = queue_exceed_counter + queue_exceed_indicator;

% state_information = (bandwidth/log(2)) * (...
%     2*Queues(:,t) + virtual_queue_reliability(:,t) - ...
%     violation_probability*threshold_Q + queue_exceed_indicator.*(...
%     virtual_queue_moment_1(:,t) - threshold_maxQ_moment_1 + ...
%     Queues(:,t).*( 1 + 2*virtual_queue_moment_2(:,t) - 2*threshold_maxQ_moment_2)...
%     + 2*( Queues(:,t) ).^3 ...
%     ) );

% Individual contributions: 
% from orignal queue
contribution_queue = Queues(:,t) + Arrivals(:,t);
% from virtual queue for reliability
% Markov inequality
% contribution_vq_reliability = Queues(:,t) + ...
%     virtual_queue_reliability(:,t) - violation_probability*threshold_Q;
% counting measure
% contribution_vq_reliability = queue_violation_indicator.*(...
%     1 + 2*virtual_queue_reliability(:,t) );
contribution_vq_reliability = ( Queues(:,t) + Arrivals(:,t) ).*...
    virtual_queue_reliability(:,t);
% form virtual queue for mean of max queue
contribution_vq_moment_1 = queue_exceed_indicator.*(...
    virtual_queue_moment_1(:,t) + Queues(:,t) + Arrivals(:,t));
% from virtual queue for 2nd moment of max queue
%-----removed for POT
% contribution_vq_moment_2 = 2*queue_exceed_indicator.*(...
%     Queues(:,t).*virtual_queue_moment_2(:,t) + ( Queues(:,t) ).^3 );


%----modified for POT
% state_information = (bandwidth/log(2)) * (...
%     contribution_queue + ...
%     contribution_vq_reliability +...
%     contribution_vq_moment_1 + ...
%     contribution_vq_moment_2 ...
%     );
state_information = (bandwidth/log(2)) * (...
    contribution_queue + ...
    contribution_vq_reliability +...
    contribution_vq_moment_1 ...
    );
this_channel = reshape( sum( repmat(eye(total_VUE_pairs), ...
    [1,1,total_resource_blocks]).*channel, 2), ...
    [total_VUE_pairs, total_resource_blocks]).*...
    resource_allocation_table;
cinr = this_channel./interferenceNnoice_estimation;
for pair = 1:total_VUE_pairs
    this_SI = state_information(pair);
    this_power = zeros( 1, total_resource_blocks);
    if this_SI > 0
        [this_CINR_inv, this_indicators] = sort( 1./cinr(pair,:), 'ascend');
        water_level = (max_transmit_power + cumsum(this_CINR_inv))./...
            [1:total_resource_blocks];
        water_level_bounded = min( water_level, this_SI/tradeoff_lyapunov);
        fill_indicator = find( ...
            (water_level_bounded - this_CINR_inv >= 0)&...
            ([this_CINR_inv(2:end) inf] - water_level_bounded >= 0) );
%         **************************
%         fill_indicator = sum( (water_level >= ...
%             [this_CINR_inv(2:end) this_CINR_inv(end)]).*...
%             (this_CINR_inv<=this_SI/tradeoff_lyapunov) );
%         ********************************
        if ~isempty(fill_indicator) % CINR is good so that power can be allocated
            this_power(1:fill_indicator) = ...
                water_level_bounded(fill_indicator) - ...
                this_CINR_inv(1:fill_indicator);
            this_dual = this_SI/water_level_bounded(fill_indicator)...
                -tradeoff_lyapunov; %not needed
        else
            this_dual = 0; %not needed
        end
        this_power_unsort(this_indicators) = this_power;
%         Transmit_power(pair,t,:) = reshape( this_power_unsort, ...
%             [1,1,total_resource_blocks]); % saving large matrix issue
        transmit_power_this(pair,1,:) = reshape( this_power_unsort, ...
            [1,1,total_resource_blocks]);
    else
%         Transmit_power(pair,t,:) = reshape( this_power, ...
%             [1,1,total_resource_blocks]);
        transmit_power_this(pair,1,:) = reshape( this_power, ...
            [1,1,total_resource_blocks]);
    end
end

%-------------------------------
% % Test power is allocated only for allocated RBs
% power_alloc = reshape( transmit_power_this, [total_VUE_pairs, total_resource_blocks])
% % returns 1 if all is well
% disp( isempty(find(power_alloc(resource_allocation_table==0),1)) )



% disp(reshape( transmit_power_this, [total_VUE_pairs, total_resource_blocks]))
% disp( sum( transmit_power_this, 3))
end